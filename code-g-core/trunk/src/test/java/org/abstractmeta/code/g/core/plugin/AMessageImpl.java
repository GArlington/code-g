package org.abstractmeta.code.g.core.plugin;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import org.abstractmeta.code.g.core.test.AMessage;
import org.abstractmeta.commandify.Commandify;
import org.abstractmeta.commandify.command.Commands;
import org.abstractmeta.commandify.core.CommandsImpl;
import org.abstractmeta.commandify.core.command.AbstractConstructorCommand;
import org.abstractmeta.commandify.core.command.AbstractFieldCommand;
import org.abstractmeta.commandify.core.command.CommandifyCollection;
import org.abstractmeta.commandify.core.command.CommandifyMap;
/**
 * This source code was automatically generated by code-g plugin.
 */

public class AMessageImpl extends AMessage implements Commandify<AMessage> {
    private transient Commands<AMessage> commands;

    public AMessageImpl(int id) {
        super(id);
        this.commands =  new CommandsImpl<AMessage>(AMessage.class, new Constructor0Command(new Object[]{id}));
    }

    public void setType(final String type) {
        commands.add(new TypeCommands(type, getType()));
        super.setType(type);
    }

    public String getType() {
        return super.getType();
    }

    public void setMap(Map<String, String> map) {
        map = new CommandifyMap<String,String>(map);
        commands.add(new MapCommands(map, getMap()));
        super.setMap(map);
    }

    public Map<String, String> getMap() {
        return super.getMap();
    }

    public void setCollection(Collection<String> collection) {
        collection = new CommandifyCollection<String>(collection);
        commands.add(new CollectionCommands(collection, getCollection()));
        super.setCollection(collection);
    }

    public Collection<String> getCollection() {
        return super.getCollection();
    }

    public Commands<AMessage> getCommands() {
        return this.commands;
    }


    public static class TypeCommands extends AbstractFieldCommand<AMessage, String> {

        public TypeCommands(String type, String previousType) {
            super("type", type, previousType);
        }

        public void execute(AMessage instance) {
            instance.setType(getValue());
        }

    }
    public static class MapCommands extends AbstractFieldCommand<AMessage, Map<String, String>> {

        public MapCommands(Map<String, String> map, Map<String, String> previousMap) {
            super("map", map, previousMap);
        }

        public void execute(AMessage instance) {
            instance.setMap(getValue());
        }

    }
    public static class CollectionCommands extends AbstractFieldCommand<AMessage, Collection<String>> {

        public CollectionCommands(Collection<String> collection, Collection<String> previousCollection) {
            super("collection", collection, previousCollection);
        }

        public void execute(AMessage instance) {
            instance.setCollection(getValue());
        }

    }
    public static class Constructor0Command extends AbstractConstructorCommand<AMessage> {

        public Constructor0Command(Object [] values) {
            super(new Class[]{int.class}, values);
        }

        public AMessage execute() {
            return new AMessageImpl((Integer)getValues()[0]);
        }

    }
}